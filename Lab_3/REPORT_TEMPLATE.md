#Laboratory work nr. 3

<br/>
<br/>
<br/>

---

<br/>

### Course: Cryptography & Security
### Author: Berestean Stefan

---

<br/>

## Theory:
Asymmetric cryptography, also known as public-key cryptography, is a process that uses a pair of related keys -- one public key and one private key -- to encrypt and decrypt a message and protect it from unauthorized access or use.
A public key is a cryptographic key that can be used by any person to encrypt a message so that it can only be decrypted by the intended recipient with their private key. A private key -- also known as a secret key -- is shared only with key's initiator.
When someone wants to send an encrypted message, they can pull the intended recipient's public key from a public directory and use it to encrypt the message before sending it. The recipient of the message can then decrypt the message using their related private key.
If the sender encrypts the message using their private key, the message can be decrypted only using that sender's public key, thus authenticating the sender. These encryption and decryption processes happen automatically; users do not need to physically lock and unlock the message.

<br/>
Many protocols rely on asymmetric cryptography, including the transport layer security (TLS) and secure sockets layer (SSL) protocols, which make HTTPS possible.

The encryption process is also used in software programs that need to establish a secure connection over an insecure network, such as browsers over the internet, or that need to validate a digital signature.


<br/>
Increased data security is the primary benefit of asymmetric cryptography. It is the most secure encryption process because users are never required to reveal or share their private keys, thus decreasing the chances of a cybercriminal discovering a user's private key during transmission.



## Objectives:
1. Get familiar with the asymmetric cryptography, stream and block ciphers.


2. Implement an example of a asymmetric cipher.

3. The implementation should, ideally follow the abstraction/contract/interface used in the previous laboratory work.

4. As in the previous task, please use a client class or test classes to showcase the execution of your programs.

---
<br/>

### Asymmetric Cipher (RSA)

#### Implementation:

* In the first step, let's create an abstract class "Cipher".
We'll have to declare 2 methods encrypt and decrypt. Later they will be implemented.
```
  public abstract class Cipher {
    public String alphabet = "abcdefghijklmnopqrstuvwxyz";

    public abstract String encrypt(String msg);
    public abstract String decrypt(String msg);

```
* Create another class which will extend previous one( RSA_Cipher ).
We'll have 2 variables p and q and should be primary numbers - pass them in constructor.And to do
not hav overflows use BigInteger.
To have a working crypting there are required keys: e and d, and modulus n. n is generated by multiplying p and q.
Next step is computing totient. Totient is the lowest common multiple of n. Another way of representing the totient is lcm((p-1),(q-1)). As p and q are primes, the lcm is (p-1)*(q-1)
 (bigP.subtract(BigInteger.ONE)).multiply(bigQ.subtract(BigInteger.ONE))

```
  private long p;
  private long q;
  
  public RSA_Cipher(long p, long q) {
        this.p = p;
        this.q = q;
        keyGen();
  }  
```
* Encryption process consists of iterating input string char by char. There is found the modular power of the next char and appended to a final string.
```
BigInteger c = msg.modPow(e, n);
```
* Decryption is performed for each encrypted char. Each char is iterated and passed through decryption function. Decryption function is a modular exponentiation with exponent d and modulus n
```
BigInteger msg = new BigInteger(eChar).modPow(d, n);
```

<br/>

---


## Conclusion

In this laboratory work we learned what is a asymmetric cypher.
Learned how to implement them in code, work with interfaces and refactor
our code.